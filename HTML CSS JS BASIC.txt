 [HTML]

<태그명 속성명="속성값">

주석 : <!-- 주석 내용 -->

<title> </title>태그를 이용해 제목을 지정할 때, 제목은 HTML 문서마다 중복되지 않도록 주의한다.
-구글이나 네이버 같은 검색 엔진 사이트에서 제목 중복되면 신뢰성이 떨어진다 판단해 노출이 적게 된다.

블록요소와 인라인요소
블록요소 : hn태그나 p태그처럼 공간과 상관없이 항상 줄 바꿈되는 태그로 작성한 코드 (C언어 비유하면 \n이 포함되는 코드인듯.)
인라인요소 : a태그나 span태그처럼 공간이 부족할 때만 줄 바꿈되는 태그로 작성한 코드 (C언어 비유하면 \n이 포함되지 않는 코드인듯.)
 

<HTML 필수 태그>

1. <hn>제목</hn>
hn태그로 작성된 텍스트는 검색 엔진에서 키워드로 인식. 따라서 검색엔진최적화(SEO)를 위해 본문에서 핵심이 되는 내용으로 제목이나 주제를 잘 선택해서 작성해야 한다.
hn 태그는 중간에 숫자를 건너 뛰지 말고 h1 태그부터 단계적으로 사용해야 한다. (생략하면 생략된 태그 이후는 검색엔진이 검색하지 않는다.)

2. <p>내용</p>
본문의 문단을 작성할 때 사용.

3. <br>
줄바꿈

4. ...기타 여러가지

5. 그룹 태그(=공간 분할 태그) - div, span
<div class="movie"> ... </div> : 블록 요소와 인라인 요소를 그룹으로 묶을 때 사용.
<span> </span> : 인라인 요소를 그룹으로 묶을 때 사용. 하나의 태그 안에 작성된 텍스트 일부만 디자인을 다르게 적용하기 위해 사용.(그룹으로 묶어 요소의 공간을 분할하면 분할된 요소에 CSS로 스타일을 적용할 수 있다.)

6. 목록 태그 (ul, ol, dl)

7. 링크와 이미지 넣기
<a>태그 : HTML에서 내부나 외부 링크를 생성.
	- : <a href = "대상 경로" target="링크 연결 방식" title="링크 설명"></a>
	-target은 보통 "_blank"를 이용(새 창으로 열리는 방식)

<img> 태그 : HTML에서 이미지 객체를 삽입할 때 이용.
	- : <img src="이미지 경로" alt="이미지 설명">

이미지를 넣을 때 내 컴퓨터에 저장된 이미지 넣으면 다른 사람이 보면 이미지 안뜬다. 이미지도 서버에 올려야 하기 때문에.

8. 텍스트 강조 태그 - strong, em

9. 폼 구성하기
1) form 태그 : HTML의 폼을 구성하는 태그는 모두 form 태그 안에 작성한다.
<form action="서버 url" method="get 또는 post"></form>
-action 속성 : 폼 요소에서 사용자와 상호작용으로 입력받은 값들을 전송할 서버의 URL 주소를 적는다.
-method 속성 : 입력받은 값을 서버에 전송할 때 송신 방식을 적는다. get 또는 post사용.

2) input 태그 : 로그인 페이지의 id, pw처럼 입력받는 요소를 생성할 때 사용.
<input type="종류" name="이름" value="초깃값">
-type 속성 : 종류가 굉장히 많다. checkbox, button, ...

3) label 태그 : form 태그 안에서 사용하는 상호작용 요소에 "이름을 붙일 때" 사용.
사용방법에 따라
-암묵적인 방법 : label 태그 내부에 폼 요소를 포함시켜 연결
	<label>
  		라벨 이름
  		<input type="text">
	</label>

-명시적인 방법 : label 태그의 for 속성을 사용하여 특정 폼 요소의 id와 연결. for 속성값과 id 속성값이 같아야 한다.
	<label for="username">유저네임</label>
	<input type="text" id="username">

label 태그의 역할
1. 웹 폼을 만들 때, 각 입력란에 무엇을 입력해야 하는지 사용자에게 알려주는 라벨을 사용 (C언어 비유하면 scanf 앞에 printf로 설명해주는 그런느낌)
2. 접근성 향상 - 스크린 리더를 사용하는 사람들은 label 태그를 통해 입력 필드에 대한 설명을 읽을 수 있다. 즉, 시각 장애가 있는 사용자가 웹 페이지를 더 쉽게 탐색할 수 있도록 돕는다.
3. 클릭 영역 확대 - label 태그를 사용하면, 사용자가 라벨 텍스트를 클릭해도 연결된 입력 필드로 포커스가 이동. 특히, 작은 체크박스나 라디오 버튼 같은 경우, 라벨을 클릭함으로써 클릭 가능한 영역이 확대되어 사용자가 더 쉽게 선택할 수 있다.

4)fieldset와 legend 태그
fieldset태그 : form 태그 안에 사용된 다양한 상호작용 요소도 fieldset 태그를 사용하여 그룹 지을 수 있다. fieldset 태그로 그룹을 지으면 그룹별로 박스 모양의 테두리가 생긴다. 그룹 지은 요소들을 legend 태그로 이름붙인다.

ex)
    <form action="#">
        <fieldset>
            <legend>그룹 이름</legend>
            <input type="button">
        </fieldset>
    </form>

5)textarea 태그 : 여러 줄의 입력 요소를 생성할 때는 input 태그가 아닌 textarea 태그를 사용.
<textarea> 초깃값 </textarea>

6)select, option, optgroup 태그 : select 태그를 사용하면 콤보박스를 생성할 수 있다. 콤보박스에 항목 하나를 추가할 때는 option 태그를 사용하고, 항목들을 그룹으로 묶고 싶다면 optgroup 태그를 사용한다.

ex)
<select>
	<optgroup label = "그룹 이름">
		<option value="서버에 전송할 값">웹 브라우저에 표시할 값</option>
	</optgroup>
</select>

select의 속성
	-size 속성
	-multiple 속성
	-selected 속성

7)button 태그
<button type="종류">버튼 내용</button>
	-type 속성값 : submit(폼을 서버에 전송할 목적), reset(상호작용 요소에 입력된 내용을 초기화), button(단순한 버튼)

최신 버전은 input 태그를 이용한 button보다는 button 태그를 이용하여 버튼을 생성한다. 단순하고, 꾸미기도 수월하기때문.

10. 폼 관련 태그에서 사용할 수 있는 추가 속성 : 지금까지 배운 폼 관련 태그에서 공통으로 사용할 수 있는 속성.
-disabled 속성 : 상호작용 요소 비활성화. input, textarea, select, button 태그에 사용가능. 태그가 비활성화되면 입력 요소는 텍스트 입력불가, 목록 상자는 항목 선택불가, 버튼 요소는 버튼 클릭 불가.
<태그 disabled>
-readonly 속성 : 상호작용 요소를 읽기 전용으로 변경. textarea, input 태그에서 사용.
<태그 readonly>
disabled 속성은 form 태그로 서버에 값을 전송할 때 값이 아예 전송되지 않지만, readonly는 값이 전송된다.

-maxlength 속성 : 입력할 수 있는 글자 수 제한. textarea태그와, input 태그의 type 속성값이 글자수 입력 관련이면 사용 가능.
<태그 maxlength="숫자">
-checked 속성 : 요소를 선택된 상태로 표시. 선택요소가 있어야 하므로 input 태그의 type속성값이 checkbox나 radio인 요소에만 사용할 수 있다.
<태그 checked>
-placeholder 속성 : 입력 요소에 어떠한 값을 입력하면 되는지 힌트를 적는 용도로 사용.
<input placeholder="입력값에 대한 힌트">

11. 표 만들기
table 태그 : HTML에서 표를 생성할 때 사용.
caption 태그 : 표 제목을 지정. table 태그 안에 첫번째로 작성해야 한다.
tr 태그 : 표에서 행을 하나 생성. 여러개 사용하고 싶으면 여러번 사용하면 된다.
th 태그 : 표에서 제목을 나타내는 열을 생성할 때 사용.
td 태그 : 표에서 일반적인 데이터를 나타내는 열을 생성할 때 사용. 
<table>
	<caption>표 제목</caption>
</table>

rowspan과 colspan 속성 : 셀을 병합할때 사용
<td rowspan="2">병합 내용</td> : 2개 행 병합.

thead,tfoot,tbody 태그 : 표에서도 행을 묶어 그룹화. thead 태그는 헤더 영역에 해당하는 행, tfoot 태그는 푸터 영역에 해당하는 행, tbody 태그는 본문 영역에 해당하는 행을 그룹 짓는다. 사용한다면 반드시 thead, tfoot, tbody 순서여야 한다. thead와 tfoot 태그는 한번만 사용할 수 있고, thead 태그로 그룹화한 행은 th 태그로 열을 생성해야 한다.
쉽게 이해하면 thead는 헤더부분, tfoot은 표 끝부분, tbody는 표 중간내용.
사용하는 이유 - 웹 접근성 향상.

col과 colgroup 태그
col : 하나의 열 그룹화
colgroup : span 속성과 함께 사용해 2개 이상의 열을 그룹화.

scope 속성


12. 멀티미디어 설정 : 멀티미디어 관련 요소로 웹페이지에서 가장 많이 볼 수 있는 것은 오디오와 비디오.
audio 태그와 video 태그로 작성가능.

audio 태그 
<audio src="오디오 파일 경로" controls></audio>

video 태그
<video src="비디오 파일 경로" controls></video>

13. 시맨틱 태그 : 웹 페이지 구조 설계. 태그의 이름만으로 태그의 용도나 역할에 대한 의미가 명확한 태그를 말한다.
1)header 태그
2)nav 태그
3)section 태그 (hn태그 중 하나를 포함) : 웹 페이지에서 논리적으로 관련 있는 내용 영역을 구분할 때 사용.
4)article 태그 : 웹 페이지에서 독립적인 영역을 구분할 때 사용.
5)aside 태그 : 웹 페이지 안에서 주력 내용이나 독립적인 내용으로 보기 어려워서 article 태그나 section 태그로 영역을 구분할 수 없을 때 사용.
6)footer 태그
7)main 태그

14. 글로벌 속성 : 태그 종류에 상관없이 사용.
1)class
2)id
...



[CSS]

<1>

1. CSS 문법 형식 : 선택자, 선언부로 구분.
선택자 : CSS 스타일을 적용할 HTML 태그(요소)를 선택하는 영역.
선언부 : 선택자에서 선택한 태그에 적용할 스타일을 작성하는 영역. {}안에 넣는다.
	-스타일은 반드시 속성과 값을 한쌍으로 작성.
	-값 뒤에 ;를 넣으면 여러 스타일을 연속해서 작성할 수 있다.

주석 : /* */

2. CSS를 HTML 문서에 적용하는 3가지 방법
1)내부 스타일 시트 사용하기 : <style> CSS 코드 </style>. 보통 head 태그 안에 사용한다. 그러나 HTML 문서를 해석할 때마다 CSS 코드를 매번 다시 읽기 때문에 성능상으로는 좋지 못하다.
2)외부 스타일 시트 사용하기 : CSS코드를 작성하는 별도 파일을 만들어 HTML 문서와 CSS를 연결.
연결방법 : link 태그 이용. <link rel="stylesheet" href="css 파일 경로">
3)인라인 스타일 사용하기 : HTML 태그에서 사용할 수 있는 style 속성에 CSS코드를 작성하는 방법.
<태그 style="CSS 코드"></태그>

실무에서는 대부분 2번을 이용한다. 코드 유지보수에 편하고, 성능적으로도 가장 좋기 때문.

<2> CSS 선택자 다루기
<기본선택자>
1. 전체 선택자 : *   HTML에서 사용할 수 있는 모든 요소를 한 번에 선택자로 지정하는 방법.
2. 태그 선택자 : 태그명{ CSS 코드 }
3. 아이디 선택자 : #id속성값{ CSS 코드 }   HTML 태그에서 사용할 수 있는 id 속성값을 이용해 선택자를 지정하는 방법.
	(id 속성값은 하나의 문서 안에서는 고유해야 한다.)
4. 클래스 선택자 : HTML 태그에서 사용할 수 있는 class 속성값을 이용해 선택자를 지정. 속성값 앞에 .기호를 붙인다. .class속성값{ CSS 코드 }
	(class 속성은 id 속성과 다르게 속성값을 중복해서 사용할 수 있다.)
5. 기본 속성 선택자 : [속성]{ CSS 코드 } 또는 [속성=값]{ CSS 코드 }
	속성 선택자는 아이디, 태그, 클래스 선택자와 함께 사용할 수 있고, 단독으로 사용할 수도 있다.
	ex) a[href]{} : a태그에 href 속성이 있는 요소 선택.
	ex) .title[href]{} : title클래스에 href 속성이 있는 요소 선택.
	ex) [href]{} : 어떤 요소라도 href 속성만 있으면 선택.
6. 문자열 속성 선택자

<조합 선택자>
1. 그룹 선택자
선택자 1, 선택자2, ... 선택자n{ CSS 코드 }
ex) p, #title, .red{ CSS 코드 }

2. 자식 선택자 : 부모 요소의 바로 하위에 있는 자식 요소에 스타일을 적용할 때 사용.
부모 선택자 > 자식 선택자{ CSS 코드 }
ex) .box > p{ CSS 코드 } : class 속성값이 box인 요소의 직계 자식 관계에 있는 p태그로 작성된 요소만 선택자로 지정.

3. 하위 선택자 : 선택자의 범위를 특정 부모 요소의 하위 요소로 한정하는 방법.
ex) div p{ CSS 코드 } : div 태그의 하위에 있는 p태그로 작성된 요소 전부 선택.

자식 선택자 vs 하위 선택자
.box p {}
.box의 모든 하위 <p> 태그를 선택(자식, 손자, 더 깊은 후손까지 포함).

.box > p {}
.box의 "직접적인 자식"인 <p> 태그만 선택. 만약 <p>가 .box의 하위 요소이긴 하지만, 중간에 다른 요소에 의해 감싸져 있다면 선택되지 않는다.


4. 인접 형제 선택자 : 앞에서 지정한 선택자 요소 "바로 다음"(이전 아님)에 있는 형제 관계 요소를 선택자로 지정.
이전 선택자 + 대상 선택자{ CSS 코드 }
ex) h1 + h2 { CSS 코드 } : h1 태그와 인접한 형제 관계이며 인접한 h2 태그에만 적용.

5. 일반 형제 선택자 : 이전 선택자 뒤에 오는 형제 관계 요소 모두 선택자로 지정
이전 선택자 ~ 대상 선택자{ CSS 코드 }

<가상 요소 선택자>
가상 요소 선택자 : HTML 문서에 명시적으로 작성된 구성 요소는 아니지만, 마치 존재하는 것처럼 취급해 선택하는 선택자 지정 방법.
기준 선택자::가상 요소 선택자{ CSS 코드 }
 ex)
	1. ::before : 콘텐츠 앞의 공간을 선택
	2. ::after : 콘텐츠 뒤의 공간을 선택
	+a : content 속성 : 위의 두 선택자에서만 사용하는 속성. CSS속성. 새로운 콘텐츠를 만들거나 추가할 때 사용.

<가상 클래스 선택자 사용하기>
가상 클래스 선택자 : 요소의 상태를 이용해 선택자를 지정하는 방법
기준 요소 : 가상 클래스 선택자{ CSS 코드 }

1. 링크 가상 클래스 선택자 : a 태그에서 발생할 수 있는 링크 상태를 이용해 선택하는 방법
	:link    한번도 방문하지 않은 링크일 떄 선택
	:visited : 한번이라도 방문한 적이 있는 링크일 때 선택
	ex) a:link{ CSS 코드 }

2. 동적 가상 클래스 선택자 : 사용자의 어떤 행동에 따라 동적으로 변하는 상태를 이용해 선택자를 지정하는 방법
	:hover  요소에 마우스를 올리면 해당 태그가 선택자로 지정됨.
	:active  요소를 마우스로 클릭하고 있는 동안 해당 태그가 선택자로 지정됨.

3. 입력 요소 가상 클래스 선택자 : 입력 요소의 특정 상태를 이용해 선택자로 지정하는 방법.
	:focus  입력 요소에 커서가 활성화되면 선택자로 지정.
	:checked 체크박스가 표시되어 있으면 선택자로 지정.
	:disabled 상호작용 요소가 비활성되면(disabled 속성이 사용되면) 선택자로 지정.
	:enabled 상호작용 요소가 활성화되면(disabled 속성이 사용되지 않은 상태면) 선택자로 지정.

4. 구조적 가상 클래스 선택자 : HTML 태그의 "사용 위치", 다른 태그와의 "관계"에 따라 요소를 선택하는 방법.
	부모요소:first-child
	부모요소:nth-child(n) , :nth-last-child(n)
	부모요소:nth-of-type(n), :nth-last-of-type(n)
	....등등

<다양한 선택자 조합하기>
지금까지 배운 것처럼 선택자의 목적은 스타일을 지정할 대상 요소를 선택하는 것이다. 선택자를 지정하는 방법도 많다.
다양한 선택자를 종류별로 나눠서 다루었지만, 서로 조합해서 사용할 수 있다.
div.box{}    class속성값이 box인 div 태그 (.boxdiv랑은 당연히 다르다.)
section#main   id속성값이 main인 section 태그
div:hover button{}  div태그에 마우스를 올린 상태일때, 해당 div태그 하위에 있는 button 태그 선택


<3> CSS 필수 속성 다루기 (선언부)

1. 적용 우선순위와 개별성
기본 스타일 시트보다 사용자가 정의한 스타일 속성이 우선 적용되고, "같은 태그 요소의 선택자가 여럿일 때는 마지막의 한 속성만 적용"된다.
이유 : CSS(Cascading Style Sheets) = 단계적으로 적용되는 스타일을 뜻하는 언어이기 때문.
어떤 스타일이 마지막에 영향을 주는지는 CSS의 개별성 규칙에 따라 결정된다.

개별성 규칙 : 인라인요소 > id > 클래스, 속성, 가상 클래스 > 태그 (부등호는 높은 점수순)순으로 적용된다.
따라서 같은 태그에 중복해서 스타일이 지정되더라도 개별성 규칙 점수에 의해 적용될 스타일이 결정된다.
하지만 실무에서 개별성 규칙 점수를 일일히 계산하는 건 현실적으로 매우 어렵다. 따라서 하나의 태그를 선택할 때는 부모 선택자부터 하위 선택자나 자식 선택자 조합으로 자세하게 적으면 우선순위가 높아진다.

!important : 다른 선택자를 모두 압도하고 이 스타일이 우선적용

2. 상속
CSS 속성은 상속된다. 모든 속성이 전부 상속되지는 않는다. 상속되는 속성이 있고 안 되는 속성이 있지만, 구분해서 외울 필요는 없다.
CSS 속성은 상속됨을 아는 것이 중요하다.

cf)
CSS의 스타일 적용 범위 : 텍스트와 관련된 속성은 상속된다. 박스 모델 및 레이아웃 관련 속성은 기본적으로 상속되지 않는다. 상속되지 않는 속성을 자식에게 적용하고 싶다면 값 : inherit;을 사용해야 한다.
<style>
	div{
		color:red;
}
<body>
	<div>
		<p>inherit</p>
	</div>
</body>

inherit이라는 텍스트에 빨간색이 적용된다. 텍스트를 직접 감싸는 p태그에 적용한 스타일이 아닌데도 텍스트에 스타일이 적용된다.



3. 단위
절대 단위 : 어떤 환경이라도 동일한 크기로 보이는 단위
px(pixel) 한 가지이다. 모니터의 화면을 구성하는 사각형 1개의 크기를 의미. CSS에서 사용할 수 있는 크기 단위 중 가장 기본. 웹 브라우저에서 다른 단위로 값을 지정하더라도 결국 px 단위로 환산되어 계산된다.


상대 단위 : 부모 요소 또는 웹 브라우저의 창 크기에 따라 상대적으로 결정되는 단위
	% : 해당 속성의 상위 요소 속성값에 상대적인 크기를 가진다. 부모 요소 속성값인지 판단하는 기준은 HTML 구조와 CSS의 계층 관계에 따라 결정
	em : 부모 요소의 텍스트 크기에 상대적인 크기를 가짐. %단위는 사용되는 속성에 따라 기준이 달라지지만, em 단위는 오로지 텍스트 크기를 기준으로 삼는다. 2em으로 지정했다면 자식 요소의 크기는 부모 요소의 font-size 속성값의 2배가 된다.
	rem : html 태그의 텍스트 크기에 대한 상대적인 값. 1rem은 html 태그의 텍스트 크기의 1배. 현대적인 웹 브라우저는 모두 html 태그의 텍스트 크기가 16px이라서 1rem은 16px과 같다.
	vw : 뷰포트 너비를 기준으로 상대적인 크기를 가진다. 1vw는 뷰포트 너비의 1/100 크기를 의미한다.
	vh : 뷰포트 높이를 기준으로 상대적인 크기. 1vh는 뷰포트 높이의 1/100 크기를 의미한다.

뷰포트 : 코드가 보이는 대상. 웹이나 모바일에서는 웹 브라우저 창의 너비가 뷰포트 너비가 된다. 


cf) 
1. 폰트 크기 = rem: 글자 크기에서 표준처럼 많이 사용. 전체 레이아웃과 일관성을 유지하기 쉽기 때문. 가끔 em도 쓰이지만, 중첩 효과로 인해 관리가 어려워질 수 있다.
2. 레이아웃 크기 = % : 부모 요소를 기준으로 너비나 여백을 설정할 때 가장 직관적.
3. vw/vh : 화면 크기를 기반으로 배경 이미지, 풀스크린 레이아웃 등을 만들 때.
4. 여백 및 간격(padding/margin) : rem이나 %가 주로 사용.
5. 반응형 디자인 : rem, vw, vh



중요) 반응형 디자인에서 rem단위를 주로 사용한다. 
html 태그의 font-size 속성값을 조정하여 전체적인 비율을 쉽게 조절할 수 있기 때문. html 태그의 font-size를 변경하면, 모든 요소의 크기가 자동으로 재계산되므로 반응형 디자인에서 매우 유리하다.

px 단위는 고정된 크기라서 반응형 레이아웃을 구현할 때 일일이 수치를 변경해야 한다.
%는 주로 레이아웃(너비, 높이 등)을 정의할 때 사용되며, 텍스트 크기와 관련된 속성에는 잘 쓰이지 않는다.
em은 부모 요소의 font-size를 기준. 부모 요소 크기 변경 시, em은 영향을 받지만, rem은 독립적.


4. 색상 표기법
	1) 키워드 표기법  -  ex) color:red; 등
	2) RGB 색상 표기법 - rgb또는 rgba(alpha) 이용. alpha값은 투명도를 의미한다. ex) color:rgb(255,0,0);
	3) HEX 표기법 : 16진수로 변환해 00~ff로 나타내는 표기법. 실무에서 가장 많이 사용하는 색상 표기법. 앞에 #을 붙인다. #RRGGBB ex) #ff0000
		16진수가 같다면 줄여서 표기할 수 있다. #ff0000 -> #f00, #335533 -> #353


<텍스트 속성으로 텍스트 꾸미기>
1. font-family 속성 - 글꼴을 지정할 수 있다. 속성값으로는 글꼴명을 적는데, 쉼표(,)로 구분하고 1개 이상의 글꼴을 나열해 지정한다. 이떄, 한글로 된 글꼴이나 공백이 있는 글꼴명은 큰따옴표("")로 감싸야 한다.
	-    font-family:<글꼴1>, <글꼴2>,,, <글꼴 유형>;
		-여러 글꼴을 쉼표로 구분해 나열하면 맨 앞에 작성한 글꼴부터 적용 가능 여부를 판단한다.
		-글꼴 유형은 글꼴의 개념이 아니라 글꼴의 형태를 의미한다.
		-따라서 다른 글꼴처럼 못 불러온다는 개념이 없다. 이러한 특징 때문에 font-family 속성으로 명시한 글꼴을 불러오지 못할 경우를 대비해 불러오려고 한 글꼴과 가장 유사한 형태의 글꼴 유형을 마지막에 항상 지정해야 한다. 그러면 지정한 글꼴을 전부 불러오지 못하더라도 텍스트가 유사한 형태로 보여져서 사용자가 웹 사이트에서 느끼는 경험을 최대한 일정하게 유지할 수 있다.
	글꼴 유형 예시 serif, sans-serif, monospace, fantasy, cursive
2. font-size 속성 : 웹 브라우저의 기본 스타일 시트의 일반적인 텍스트 크기는 16px
	font-size:<크기>;

3. font-weight 속성 : 텍스트의 굵기를 지정하는데 사용.
	font-weight:<숫자 표기법>|<키워드 표기법>;
	-숫자 표기법 : 숫자 100단위로 텍스트 굵기를 표기하는 방법. 100~900까지의 값 사용. 100이 가장 얇고 900이 가장 굵게 표시된다.
	-키워드 표기법 : 텍스트 굵기를 키워드로 표시하는 방법. normal(400), bold(700), bolder,  lighter(둘은 상대적 값. lighter는 부모 요소의 굵기보다 얇게 지정되고, bolder는 부모 요소의 굵기보다 굵게 지정된다. 실무에서는 normal이나 bold를 주로 사용한다.

4. font-style속성 : 글꼴의 스타일을 지정할 떄 사용.
	font-style:<속성값>;
	-속성값 : normal, italic(이탤릭체로 표시), oblique(기울임꼴로 표시)

5. font-variant 속성 : 영문 텍스트를 크기가 작은 대문자로 변경할 때 사용.
	font-variant:<속성값>;
	-속성값 : normal, small-caps(텍스트를 크기가 작은 대문자로 변환)

6. text-align 속성 : 텍스트를 정렬할 때 사용.
	text-align:<속성값>;
	-속성값 : left, center, right, justify(텍스트 양쪽정렬)

7. text-decoration 속성 : 텍스트를 꾸며 주기 위해 사용. 꾸민다는 것은 텍스트에 선을 긋는 것을 말한다.
	text-decoration:<속성값>;
	-속성값 : none, line-through, overline, underline

8. letter-spacing 속성 : 글자 사이의 간격을 조절할 때 사용.
	letter-spacing:normal|<크기>;

9. line-height 속성 : 텍스트 한 줄의 높이를 지정할 때 사용하는 속성.
	line-height:normal|<속성값>;
	-속성값 : normal, 숫자, 퍼센트, 크기
	-line-height가 font-size보다 작으면 윗줄과 아랫줄의 텍스트가 겹쳐 보이면서 가독성이 떨어질 수 있다. 따라서 line-height는 속성값을 항상 font-size보다 크게 지정하는 편이 좋다.


<박스 모델을 구성하는 속성 다루기>
박스모델 : 모든 HTML 요소가 사각형의 박스로 둘러 쌓여 있다는 개념. HTML 문서에서 사용된 각각의 요소가 어떤 원리로 웹 브라우저에 배치되어 표시되는지 이해하기 위해 필요한 개념이다. 박스 형태의 요소들을 하나씩 원하는 곳에 배치해 원하는 모양으로 만들어 나가는 것이 웹 페이지를 만드는 핵심이다.

CSS의 박스 모델(Box Model) 개념에 따르면, HTML의 각 태그는 하나의 사각형 상자로 표현된다. 이 상자는 4가지 층으로 구성된다.
박스 모델의 구성요소 : margin, border, padding, content
핵심) 모델 구성 요소( margin, border, padding, content)는 HTML의 각 요소마다 독립적으로 적용된다. 즉, 페이지 안에 있는 모든 태그마다 따로 정의되고 적용된다고 생각하면 된다.

1. margin 영역 : 박스 모델에서 가장 외부에 있는 영역. 요소의 외부 여백을 담당한다.
박스모델은 사각형 모양이라서 각 방향에 해당하는 속성이 독립적으로 존재한다. margin영역을 다룰 때 사용할 수 있는 속성으로는 margin-top, margin-right, margin-bottom, margin-left가 있고, 모든 방향을 통합해 margin 속성으로 사용할 수도 있다. 속성값에는 크기를 넣으면 된다.
ex) margin-top:<크기>;  ,  margin: <margin-top> <margin-right> <margin-bottom> <margin-left>; 등 방법이 많다.
네 방향을 한번에 정할 수 있는 margin속성은 속성값을 작성하는 방법에 따라 적용되는 방식이 달라진다. 
	-3개를 적으면 순서대로 margin-top, margin-right, margin-bottom의 값이고, 생략된 margin-left 값은 마주보는 margin-right와 같은 값을 적용한다.
	-2개를 적으면 (margin-top, margin-bottom) (margin-left, margin-right)가 그룹으로 묶여 같은 값으로 지정된다.
	-1개를 적으면 모든 방향이 같은 값을 가지게 된다.

margin 겹침 현상 : 인접한 margin 값이 둘 중 더 큰 값으로 통일되는 것을 말한다. 이때, 합쳐지는 게 아니라 더 큰 값을 가진 margin 영역이 된다. 즉 같은 레벨(형제 관계)에 있는 요소들의 margin 영역이 중첩되면 더 큰 값을 가진 margin 영역으로 병합되어 출력된다.
ex) 두 요소 사이에서 한 요소의 margin-bottom값이 20px이고, 다른 한 요소의 margin-top값이 30px이라면 두 요소 사이의 간격은 50px이 되는 것이 아니라 30px이 적용된다.

2. border 영역 : margin보다 안쪽에 위치하며 요소의 테두리(경계선)를 담당한다.
border영역도 margin 영역과 마찬가지로 상하좌우 4방향의 속성이 있다. 또한 border 속성은 margin 속성과 달리 여러 속성값이 복합적으로 사용된다.
형식 : border : <border-width> <border-style> <color>;
ex) border : 2px solid blue;
border속성과 border-<방향>속성 모두 똑같이 border-width, border-style, color속성값을 사용한다. 

요약) border 속성은 한 줄로 여러 가지 설정을 할 수 있는 단축 속성(shorthand)이다. 단축속성이란, 속성값으로 다른 속성의 값을 사용하는 속성을 말한다. 이 속성들은 여러 개의 다른 속성을 하나의 속성으로 축약해서 작성한다.

border-width 속성 : 테두리의 굵기 지정. 속성값으로는 단위를 포함한 크기를 사용.
border-style 속성 : 테두리모양 지정.
color는 이전에 배웠던 것과 동일.


3. padding 영역 : margin, border영역보다 안쪽에 있으며 요소의 내부 여백을 담당한다.
padding 영역에서 사용할 수 있는 속성은 margin 영역에서 사용하는 속성과 형식이 매우 비슷하다.


4. content 영역 : 시작 태그와 종료 태그 사이에 사용된 콘텐츠가 속하는 영역. 따라서 달느 박스 모델의 구성 요소와는 다르게 content 영역은 content 영역 자체를 다루는 속성이 없다.
content 영역에 영향을 주는 속성
	1) width와 height 속성	width:<크기>; height:<크기>;
	2) box-sizing 속성 : 화면에 보이는 요소의 width와 height는 "외부 여백인 margin 영역을 제외하고" border, padding, content 영역을 전부 포함한 크기가 된다. 따라서 어떤 요소를 화면에 표시할 때 처음 의도한 것처럼 100px로 표시하려면 width 속성값을 더 작게 설정하거나, box-sizing속성을 사용한다.
		-box-sizing:<속성값>;  : width, height 속성의 적용 기준을 지정한다. 기본으로 content-box값이 적용된다.
		-속성값으로는 content-box(width, height 속성의 적용 범위를 content 영역으로만 제한한다.)와 border-box(width, height 속성의 적용 범위를 border 영역으로 제한한다.즉, content+padding+border 계산한다는 소리이다.)가 있다.
결과적으로 box-sizing 속성값을 border-box로 지정하고 요소의 너비와 높이를 다루면 훨씬 편하게 제어할 수 있다.

<박스 모델의 성격과 display 속성>
HTML의 모든 태그는 박스 모델을 가지고 있는데, 이를 자세히 들여다보면 박스 모델도 블록, 인라인, 인라인 블록이라는 서로 다른 성격이 존재한다.
블록 성격 : hn, p, div 태그를 사용했을 때 요소의 너비가 콘텐츠 유무와 상관없이 항상 가로 한 줄을 다 차지하는 것을 말한다. 그래서 이 태그들을 여러번 사용하면 무조건 줄 바꿈된다.

인라인 성격 : a, span, strong 태그를 사용했을 때 요소의 너비를 콘텐츠 크기만큼만 차지하는 성격을 말한다. 그래서 이 태그들을 여러번 사용할 때 웹 브라우저의 수평 공간이 남아 있으면 한 줄로 배치된다.

인라인 블록 성격 : 인라인 성격처럼 요소의 너비가 콘텐츠의 크기만큼만 차지하지만, 그 외의 성격은 블록 성격을 가지는 복합적인 성격을 말한다.
img태그를 사용할 때 웹 브라우저의 수평공간이 남아있으면 한 줄로 배치된다.

블록 vs 인라인 vs 인라인 블록
위 3가지 성격은 박스 모델의 구성요소와 관련한 속성을 적용할 때 조금씩 차이가 있다.
블록과 인라인 블록은 width, height, margin, padding 속성이 전부 적용된다. 인라인 성격은 width, height 속성은 적용되지 않고 padding과 margin 속성은 각각 왼쪽과 오른쪽 방향만 적용된다. 
ex) span 태그에 width 속성이나 height 속성을 지정하면 너비와 높이가 설정되지 않는다. padding속성과 margin 속성도 위쪽과 아래쪽은 적용되지 않는다.

display 속성
HTML 태그가 기본으로 가지고 있는 박스 모델의 성격은 display 속성을 사용하면 변경할 수 있다. 속성값 : block, inline, inline-block 사용.
ex) 블록 성격인 태그를 인라인 성격으로 바꾸고 싶다면 dispaly 속성값을 inline으로 지정하면 된다.


<배경 속성으로 요소의 배경 설정하기>
박스모델에서 padding과 content 영역은 요소의 배경을 나타내는 영역이다. 박스 모델의 배경에는 색상이나 이미지와 같은 스타일을 지정할 수 있다.

1. background-color:<색상값>;

2. background-image:url('이미지 경로'); 요소의 배경에 background-image 속성을 사용하면 이미지를 넣을 수 있다.
주의사항
	-요소의 배경 크기가 반드시 있어야 한다. 이 속성은 요소의 배경에 이미지를 삽입하는 원리이기 때문에 요소 배경의 width와 height를 지정해야한다. background-color 속성도 해당한다.
	-이미지의 크기가 요소의 배경 크기와 맞지 않으면 어색하게 보인다. 요소 배경이 삽입하려는 이미지보다 작으면 잘려보이고, 크면 반복되어 채워진다.

3. background-repeat:<속성값>; 
위에서 크면 반복되어 채워지는데, 이미지 반복 설정을 바꾸려면 background-repeat 속성을 사용한다. 
	속성값에 따라 바뀌는 설정 : no-repeat, repeat-x, repeat-y, repeat, round, space

4. background-size:auto|cover|contain|<너비 높이>;
	요소의 배경 크기가 이미지보다 작을 때 이미지가 잘려보이는 문제를 해결할 수 있다. 위 속성으로 이미지 크기를 지정해서 처리한다.

5. background-position:<x 위치><y 위치>;
삽입하려는 이미지의 위치를 결정할 수 있다.
background-position 속성은 background-size 속성값을 둘다 cover로 지정해서 같이 사용하면 좋다. 이미지가 정중앙에 있는 것처럼 보이기 때문이다.
cf) 100%는 비율에서 가장 큰 값이기 때문에 x축에 사용하면 가장 오른쪽, y축에 사용하면 가장 아래쪽을 의미한다.

6. background-attachment:<속성값>;
요소에 삽입된 이미지를 스크롤할 때, 이미지의 작동 방식을 결정한다.

7. background 속성으로 한 번에 지정하기
앞에서 배운 배경 속성들을 background 속성으로 한 번에 지정할 수 있다.
순서는 상관없고, background-size 속성은 항상 background-position 속성값을 먼저 작성하고 나서 /로 구분한 후 사용해야 한다.
background:<color 속성값> <image 속성값> <repeat 속성값> <position 속성값/size 속성값> <attachment 속성값>;


<위치 속성으로 HTML 요소 배치하기>
CSS에서 제공하는 속성 중에는 HTML 요소를 기본 흐름에서 벗어나서 원하는 곳에 배치할 수 있는 속성이 있다. 이 속성들은 요소의 위치에 관여한다고 해서 위치속성 이라고 한다.

1. position:<속성값>;
HTML 요소를 기본 흐름에서 벗어나 좌푯값에 따라 배치할 때 사용한다.






 [JavaScript]
웹 브라우저는 HTML과 CSS파일의 코드가 직접 수정되기 전까진 항상 같은 내용을 표시하는데, 이 방식을 정적 웹(static web)이라고 한다.
현대적인 웹에서는 이미 해석이 끝나 웹 브라우저에 표시된 내용을 인위적으로 조작하거나 상호작용하게 할 수 있다. 이러한 웹을 정적 웹과 대비해 동적 웹(dynamic web)이라고 한다. 동적 웹처럼 작동하게 하려면 Javascript라는 언어를 사용해야 한다.

cf)
JavaScript는 웹 브라우저 환경에서 실행되도록 설계된 언어이다. 따라서 브라우저에서는 별도의 설정 없이 자바스크립트를 실행할 수 있지만, Visual Studio Code(VSCode)는 브라우저가 아니기 때문에 바로 실행되지 않는다.


<1>

<자바스크립트 코드 작성 방법>
1. HTML 파일과 자바스크립트 연결하기 : HTML 문서와 자바스크립트 파일을 연결하는 2가지 방법
	1) 내부 스크립트 방법 : HTML파일에서 script 태그의 콘텐츠 영역에 자바스크립트 코드를 작성한다.
		<body>
			<script>
				document.write("내부 스크립트 방법");
			</script>
		</body>
	2) 외부 스크립트 방법 : js 확장자로 된 별도의 파일을 생성하고 생성한 파일에 자바스크립트 코드를 작성한 뒤, HTML 문서와 연결하는 방법이다.
		-HTML 문서를 생성해 .js파일과 연결한다. script 태그에 이미지 경로를 입력할 때 사용한 src 속성을 사용해 연결하려는 파일 경로를 입력한다.
		<body>
			<script src="파일명.js"></script>
		</body>
		-script 태그는 항상 body 태그의 종료 태그(= </body> 바로 전에 사용한다. Why?
			-웹 브라우저는 HTML 문서를 첫번째 줄 부터 해석하는데, 사용자에게 당장 보여 줘야 하는 영역은 HTML과 CSS가 가장 관련도가 크다. 그런데 head 태그 안에 script 태그를 사용했는데 파일 해석이 오래걸리면 웹 브라우저는 다음 줄을 해석하지 못하고 대기한다.(동기적으로 실행되기 때문). 따라서 웹 브라우저에 내용이 표시되는 전체 시간도 길어지기 때문에 성능과 실행순서 면에서 종료 태그 바로 전에 사용하는 것이 좋다.

<Before We started>

1. 주석 : //       and     /* */
2. 자바스크립트 오류 확인 방법 : 컴파일(코드를 실행하기 전에 모든 코드를 컴퓨터가 이해할 수 있는 기계어로 변환한 후 실행)과 인터프리터(코드를 한번에 한줄 씩 실행하는 방식)중 인터프리터 방식으로 실행된다.


<2>

<자바스크립트 기초문법> cf) 다른 문법과 헷갈릴 만한, 구별되는 내용 선별해서 작성.
1. 변수
	var num = 10;   -> var:키워드 num:식별자(=변수명)
		키워드
			- var
			- let : var 키워드보다 여러 기능이 개선됨. 
				-var 키워드로 선언한 변수명은 중복해서 생성할 수 있지만, let 키워드는 변수명을 중복 선언하지 못하게 한다.
				-호이스팅(hoisting) 되지 않는다.   
				-스코프의 범위가 var과 다르다. 이 때문에 실무에서는 let 키워드로 선언하기를 권장한다. 하지만 let 키워드 아직 지원안하는 곳도 있기 때문에 잘 취사선택해야 한다.

cf) 호이스팅 : 끌어올린다. 변수 선언을 js의 스코프 맨 위로 올려 실행하는 것.
js 엔진이 변수 및 함수 선언을 코드 실행 전에 메모리에 먼저 할당하는 동작.
호이스팅의 장점 :
	-1) 가독성 증가 : 함수를 선언보다 먼저 호출 가능, 코드 흐름이 직관적
	-2) 코드 유연성 : 선언 위치와 관계없이 변수와 함수를 사용할 수 있음
	-3) 함수 선언과 표현식의 차이 명확 : 선언문은 호이스팅됨, 표현식은 호이스팅되지 않음


2. 상수
	- const : 기본 내용은 let 키워드와 같다. (변수명 중복선언안되고, 호이스팅 안되고, 스코프 차이)
		- const 키워드와 let 키워드가 다른점은, const 키워드는 재할당이 안 된다는 점이다. 당연하게도 변수가 아닌 상수니까.
		- 재할당이 안되기 때문에 선언하고 바로 초기화 해야한다. 나중에 할당하면 안됨.

3. 식별자 표기법 
	-카멜 표기법 : 첫글자는 영문 소문자로 시작하고, 2개 이상의 단어가 조합되면 각 단어의 첫글자를 대문자로 표기. 주로 변수명이나 함수명, 객체의 속성명을 지을 때 사용.
		-ex) firstName, lastName
	-언더스코어 표기법 : 2개 이상의 단어가 조합될 때, 각 단어를 _ 기호로 연결해 표기하는 방법. 상수의 식별자를 지을 때 사용.
		-ex) FIRST_NAME, last_name
	-파스칼 표기법 : 각 단어의 첫글자를 대문자로 작성하는 방법. js에서 생성자 함수명을 지을 때 사용.
		-ex) FirstName, LastName

<자료형>
js의 자료형은 기본 자료형과 참조 자료형으로 구분할 수 있다.
기본 자료형 : 문자, 숫자, 논리, undefined, null, symbol 자료형 등
참조 자료형 : 객체

문자열 연결 연산자(+) : js는 문자열과 문자열을 덧셈 기호로 연산하면 서로 연결된다. (파이썬 +랑 비슷한듯)
백틱(`)을 이용한 템플릿 문자열 : 큰따옴표나 작은따옴표로 문자열을 정의하지 않기 때문에 문자열에 큰따옴표나 작은따옴표가 있어도 영향을 받지 않는다.
	-Enter를 눌렀을 때 줄 바꿈이 적용된다.
	-${}문법을 이용해 문자열에 변수 또는 식을 넣을 수 있다.
숫자형 : js는 정수와 실수를 구분하지 않고 전부 하나의 숫자 자료형(숫자형)으로 취급한다.
	-ex) let num=10; let num2=0.1;
	-다만, js는 실수를 부동 소수점 방식으로 표현하는데, 실수를 부동 소수점 방식으로 표현하면 실수 계산이 정확하지 않다.
		-ex) let sum = 0.1 + 0.2;    console.log(sum);를 하면 0.300000000004 이런식으로 나온다. 따라서 이거 생각해야 한다.
undefined : 데이터 할당안하면 할당되는 자료형
null

객체 : js의 핵심 자료형. 객체 자료형에서 파생되는 자료형으로 배열, 객체 리터럴, 함수가 있다.
	-배열 : [ ] 로 표현. 선언은 let arr = [1, 2, 3]; 이런식으로 하면 된다. 배열은 숫자형 외에도 js의 모든 자료형을 정의할 수 있다. 한 배열안에 여러 자료형 넣어도 된다는 소리.
	-객체 리터럴 : {}로 표현. 파이썬의 딕셔너리랑 비슷하다. 키와 값이 한쌍이다. key1:value1 이런식으로 표현한다.
		-let 변수명 = {korean : 80, math : 80}; 이런식으로 표현한다.
		-객체 리터럴의 각 값에 접근할 때 배열처럼 대괄호([])사용하거나, .로 접근가능하다.

<연산자>
c연산자들과 비슷하다. 후위,전위연산자 ++ -- 등도 있다.
x===y : x와 y의 값과 자료형이 같으면 true 반환. 값이 같고 자료형도 같아야 true를 반환
x!==y : x와 y의 값과 자료형이 다르면 true 반환. 값이 다르거나 자료형이 다르면 true를 반환(값은 같아도 자료형이 다르면 연산결과는 true이다. )

숫자 10과 문자열 '10'의 비교 : ==으로 하면 true가 반환되지만 ===로 하면 false를 반환한다.
	-부등 연산자는 값만 비교하기 때문.

논리 연산자 : 참/거짓이 아닌 피연산자 자체를 반환한다. 다른 언어랑 다르다.
js의 자료형 중 ""(빈 문자열), undefined, 0, null만 거짓으로 평가되고 나머지는 참으로 평가된다.
	- x && y : x가 참이면 y를 반환하고, 거짓이면 x를 반환한다.
	- x || y : x가 참이면 x를 반환하고, 거짓이면 y를 반환한다.
	- !x : x가 참이면 false를 반환하고, 거짓이면 true를 반환한다.

형 변환 : 
	-암시적 형변환
	-명시적 형변환 : String() 메서드를 사용하여 숫자형을 문자열로 명시적 형 변환을 할 수 있다.

<조건문>
1. if, else, else if문 : C언어와 같다.
	if(조건식){
}
2. switch문 : C언어와 같다.

if문은 조건에 식을 사용하고, switch문은 조건에 값을 사용한다. 따라서 범위를 이용한 조건을 작성할 때는 if문이 적합하고, 값이 하나일때는 switch 문이 더 적합하다.

<반복문>
1. while문
2. do...while문
3. for(초기값; 조건식; 증감식)
위 세가지는 모두 C언어와 동일하다.

4. for...in   파이썬이랑 비슷한듯.
for(임시변수 in 배열/객체 리터럴){
}
for문의 소괄호 안에 in 키워드를 두고 키워드의 오른쪽에는 탐색의 대상이 되는 배열 또는 객체 리터럴, 왼쪽에는 배열 또는 객체 리터럴을 탐색해서 키를 저장할 임시변수를 놓는다.
	-배열 접근 시 배열의 순서대로 접근하는 것을 보장하지 않는다.

5. break문
6. continue문

<3> js 함수 다루기
js에서 함수는 객체에서 파생된 자료형 중 하나로 볼 수 있다.

<함수 정의하기>
1. 함수 선언문으로 함수 정의하기
	- function 식별자(){}
	- 식별자=함수명으로 생각하면됨.
	- 함수명();으로 호출하면 된다.

2. 함수 표현식으로 함수 정의하기
함수는 객체에서 파생된 자료형이다. js에서 자료형은 변수에 할당할 수 있어야 한다. 따라서 함수도 변수에 할당할 수 있는데, 이를 이용한 함수 정의 방법을 함수 표현식이라고 한다. 함수 표현식은 변수에 할당하는 함수에 식별자가 있으면 "네이밍 함수", 없으면 "익명 함수"로 다시 구분한다.

	- const 변수명 = function(){};			//익명 함수
	- const 변수명 = function 식별자(){};		//네이밍 함수
이렇게 선언하면 식별자로 함수를 호출하지 않고, 할당한 변수명으로 호출한다. 물론 함수를 그냥 호출할 수도 있다.
함수 표현식으로 함수를 정의할 때는 const 키워드를 주로 사용한다. var, let키워드를 사용해도 문제없지만, const키워드로 정의하는 것이 좋다. 보통 함수는 일관된 목적을 가진 코드 집합이라서 재정의해서도, 재할당해서도 안 되는 경우가 많기 때문이다.

3. 화살표 함수로 함수 정의하기
	- () => {};
화살표 함수는 익명 함수로만 정의할 수 있어서 함수를 호출하려면 정의된 함수를 변수에 할당하는 방법인 함수 표현식을 사용해야 한다. 제일 많이 사용한다.

2번과 3번방식으로 함수를 선언한다면 변수에 할당해야하므로 함수끝에 ;를 붙여야 한다.

<함수 기능 확장하기>
1. 매개변수와 인수 : C언어와 같다. (자료형은 적을 필요 없다.)
2. return문

<함수 특징 이해하기>
1. 스코프 - js에는 함수 스코프 방식과 블록 스코프 방식에 따라 전역 스코프와 지역 스코프의 참조 범위가 달라진다.
	-함수 스코프 : C언어와 동일하다.
	-블록 스코프 : {}로 구성된 블록문 기준으로 스코프의 유효 범위를 나누는 방식. let과 const 키워드로 선언한 변수에 한해서 적용되고, var은 상관없다. var키워드는 함수 스코프 방식으로만 스코프를 나누기 때문.
	-참조 우선순위 : let, const 키워드는 같은 식별자의 중복 선언이 불가능한데, 정확하게는 "같은 스코프 영역에서 중복 선언이 불가능". 전역스코프와 지역스코프에 같은 식별자를 가지는 참조 대상이 있다면, 먼저 같은 지역 스코프의 식별자를 참조한다. 같은 지역 스코프에서 참조할 식별자를 찾지 못할 때만 전역 스코프에서 찾는다.

2. 함수 호이스팅
	-호이스팅은 var키워드로 선언한 변수에만 적용되고 let과 const키워드로 선언한 변수에는 적용되지 않는다. 함수도 호이스팅된다.
	-함수 선언문으로 정의된 함수는 호이스팅에서 선언부로 보기 때문에, 잘 실행된다. 하지만, 함수 표현식과 화살표 함수 방식으로 정의된 함수는 선언부가 변수를 선언한 부분이므로, 함수가 아니다라는 메시지가 나올 수 있다. 물론 호이스팅 되기는 한다. 단, let이나 const키워드로 선언했다면 호이스팅 자체가 되지 않는다.
	-지역변수는 해당 함수 스코프의 최상단으로 호이스팅되고, 전역변수는 전역 스코프의 최상단으로 호이스팅된다.

<즉시 실행 함수 사용하기>
즉시 실행 함수 : 함수를 정의하면서 동시에 실행까지 하는 함수. init과 같은 함수는 한번 실행되고 말건데, init식별자를 계속 못쓰게 된다. 이를 "전역 스코프가 오염됐다"라고 표현하는데, 이 경우에 즉시 실행 함수로 함수를 정의하면 전역스코프가 오염되는 것을 방지할 수 있다. 즉시 실행함수는 한 번 실행되고 나면 메모리에 데이터가 남아 있지 않는다.
(function(){})();

<4>

<js 객체 다루기>
뇌피셜 : 파이썬에서의 클래스가 js에서는 객체로 부르는 느낌임.
객체 : 자료형의 관점에서, 키와 값으로 구성된 속성의 집합.
객체는 {}를 이용해 생성할 수 있는데, 이런 방법을 "리터럴 방식"으로 객체를 생성했다고 표현한다.
객체는 데이터의 종류를 가리지 않으므로 모든 자료형의 데이터를 값으로 가진다. 
	ex)배열, 숫자, 논리 데이터를 객체의 속성으로 추가할 수 있다. 물론 객체 안에 또 다른 객체나 함수(이 경우 메서드)가 들어갈 수도 있다.
		메서드 : 객체에서 속성의 값으로 함수가 들어갈때, 이를 메서드라고 칭한다.(객체에 정의된 함수)
보통, 객체의 키는 문자열로 작성하는데, 큰따옴표나 작은따옴표로 표시하지 않아도 문제되지 않는다. 다만 키에 공백이 들어간 경우에는 따옴표를 꼭 사용해야 한다.

<객체 속성 다루기>
1. 객체 속성에 접근하기
	1)
대괄호 연산자 []를 사용해 객체의 속성에 접근. 객체명 뒤에 대괄호를 붙이고 대괄호 안에 키를 넣는다. 이때 키는 반드시 큰따옴표나 작은따옴표로 감싼 문자열 형태로 작성해야 한다.
	-객체명["키"] 
	-객체의 속성값이 배열, 객체 리터럴, 함수라면 어떻게 접근하느냐 :
		-속성값이 객체 리터럴일 때 : 대괄호를 연속으로 사용해 접근하면 된다. ex) person["name"]["firstName"]
		-속성값이 배열일 때 : 배열의 각 데이터에 접근하기 위해 대괄호 연산자에 인덱스를 사용한다. ex) person["likes"][0]
		-속성값이 함수일 때 : 함수호출 할 때는 ()를 사용한다. ex) person["printHello"]()
	2)
마침표 연산자 .를 이용해 객체의 속성에 접근. 객체 속성에 접근하려면 접근할 객체명과 객체 속성의 키를 마침표 연산자로 연결하면 된다. 키를 큰따옴표나 작은따옴표로 감싸면 오류가 발생한다.
	-객체의 키 식별자에 공백이 있다면 마침표 연산자는 사용할 수 없고 대괄호 연산자로만 접근할 수 있다. 공백이 있는 키는 큰따옴표나 작은따옴표로 감싸야 하는데, 마침표 연산자 접근 방식에서는 큰따옴표나 작은따옴표를 붙여서 사용할 수 없기 때문.
	-person.name.firstName

2. 객체 속성 값 변경하기
객체로 정의된 값을 바꾸기 위해 키로 속성에 접근해서 값을 재할당하면 된다.
	-person.name = "Kim";

3. 객체 속성 동적으로 추가하기
객체 속성에 키로 접근해 값을 할당하려 할때, 해당 키가 객체에 없으면(=객체에 없는 속성이라면) 해당 키와 값으로 구성된 새로운 속성이 객체에 추가된다.
즉, 속성에 접근해서 =으로 값을 할당하면 값이 변경되거나 새로운 속성이 추가된다. 당연하게도 객체 속성 값이 함수, 배열, 객체 리터럴일 때도 같은 방법으로 값을 변경하거나 새로운 속성을 추가할 수 있다. 이렇게 이미 만들어진 객체에, 나중에 속성을 추가하는 것을 "속성을 동적으로 추가한다"라고 한다.

4. 객체 속성 동적으로 삭제하기
동적으로 추가하듯이 동적으로 삭제할 수 있다. delete 키워드를 명시하면 해당 속성이 삭제된다.
	-delete person.name;

5. 객체의 데이터 관리 방법 이해하기
js에서 자료형을 기본 자료형과 참조 자료형으로 나누는 이유 : 데이터 관리 방식이 다르기 때문.
기본 자료형 : 변수에 데이터를 할당할 때 데이터 그 자체가 할당된다. 즉, 복사한 값을 재할당할 때 한족 데이터가 변경되어도 서로 영향을 미치지 않게 복사된다. 이를 "깊은 복사"라고 한다.

참조 자료형 : 변수 공간에 데이터가 할당되는 것이 아니고, 데이터가 위치하고 있는 메모리의 주소 값만 할당된다. js에서는 이를 "참조한다"고 표현한다.
const 변수에서 해당 변수에 다른 객체를 재할당하려고 하면 오류가 발생한다. const 키워드가 재할당이 안되므로. 하지만, 변수에 할당된 객체에 속성을 추가하거나 값을 변경하는 건 가능하다. 변수의 입장에서는 데이터를 재할당하는 것이 아니라, 변수에 할당된 객체의 주소 값은 그대로이고 주소 값이 참조하는 원본 객체 데이터만 변경되기 때문에 기존 데이터를 변경하거나 새로운 속성을 추가할 수 있다.
객체가 변수에 할당될 때 변수는 주소 값만 가지고 있어서 복사할 때도 주소값만 복사하기 때문에, 하나의 속성값만 바꿔도 둘다 바뀐다. 이렇게 데이터를 복사했을 때 한 쪽 데이터가 변경되면 다른 쪽 데이터도 변경되어 서로 영향을 받는 것을 "얕은 복사"라고 한다.



아래에서 배우는 것들의 핵심 : JS에서는 HTML 요소를 동적으로 추가할 수 있다! 매우 유용하다.
ex) document.createElement()를 사용하면 HTML 문서에 새로운 요소를 동적으로 생성할 수 있고, appendChild() 같은 메서드를 사용해서 생성한 요소를 부모 요소에 추가할 수 있다. HTML 문서에는 존재하지 않지만, JS코드에서 만들어지고 추가되는 것이다.

<표준 내장 객체 사용하기>
js에서는 개발 편의를 위해 수많은 객체가 미리 만들어져 있다. 이렇게 만들어진 객체는 js에 기본으로 내장되어 있어서 스코프의 위치를 따지지 않고(= 표준 내장 객체가 어디서든 접근 가능하다는 것을 의미. 전역 스코프에 속한다는 뜻) 모든 영역에서 공통으로 사용할 수 있다. 이렇게 js에 기본으로 내장된 객체를 표준 내장 객체라고 한다.

1. 문자열을 다루는 String 객체
String 객체 : 기본 자료형에서 문자열을 다룬다. 문자열에서 사용할 수 있는 속성과 메서드가 정의되어 있다. 
"실무에서 자주 사용하는" String 객체의 속성과 메서드는 다음과 같다.

속성
	-length : 문자열의 길이를 반환한다.
메서드
	-includes()
	-replace()
	-replaceAll()
	-split()
	-toUpperCase()
	-trim()
	-indexOf()

2. 배열을 다루는 Array 객체
Array 객체는 기본 자료형 중 배열을 다루는 객체. 배열에서 사용할 수 있는 많은 속성과 메서드가 정의되어 있다.
속성
	-length
파괴적 메서드 : 메서드를 사용했을 때 원본 데이터를 변경하는 메서드.
	-push()
	-pop()
	-unshift()
	-shift()
	-sort()
	-reverse()
비파괴적 메서드 : 원본을 변경하지 않는 메서드.
	-forEach() : 배열 안의 요소를 순회하면서 콜백 함수인 function(v)를 호출해 접근한 요소의 값을 출력한다. 반복문으로 배열 요소에 접근하는 것과 비슷한 기능을 제공한다.
	-filter()
	-find()
	-findIndex()
	-includes()
	-join()

cf) 콜백 함수 : 다른 함수의 인자로 전달되어, 나중에 그 함수에 의해 호출되는 함수. 간단히 말해, "나중에 호출할게"라는 약속을 하고 넘겨주는 함수


3. 날짜와 시간을 다루는 Date 객체
Date객체에는 날짜 및 시간과 관련 있는 메서드가 정의되어 있다. 따라서 Date 객체의 메서드를 활용하면 js로 날짜와 시간을 처리하는 작업이 매우 간단해진다.
	-인스턴스 만들기 : Date객체를 사용하려면 먼저 Date 객체를 호출해 날짜와 시간 데이터를 생성해야 한다. new키워드로 Date 객체를 호출하면 현재 날짜와 시간 정보를 기반으로 날짜와 시간 데이터가 생성된다. 이때, 생성되는 데이터를 js에서는 "인스턴스"라고 한다. 따라서 date 변수에 할당된 데이터는 Date 객체의 인스턴스이다.
		ex) const date = new Date(); 이 방법 말고도 여러가지가 있다. 
	-메서드로 날짜와 시간 정보 가져와서 설정하기 : Date객체의 메서드는 1. 날짜와 시간 정보를 가져오는 메서드와 2. 날짜와 시간 정보를 설정하는 메서드로 구분할 수 있다. get으로 시작하는 메서드는 날짜와 시간정보를 가져오고, set으로 시작하는 메서드는 날짜와 시간 정보를 설정한다.
	-날짜 간격 계산하기 : getTime()메서드는 1970년 1월 1일 12:00 이후의 시간을 밀리초 단위로 반환한다. 이 결과를 이용해 두 날짜 사이의 간격을 구할 수 있다.

4. 수학 연산을 다루는 Math 객체
Date 객체는 new 키워드로 Date 객체의 날짜 데이터인 인스턴스를 생성해 변수에 할당한 뒤에 사용했지만, Math 객체는 new 키워드 없이 Math 객체에 바로 메서드를 사용한다.
	-Math.floor()
	-Math.ceil()
	-Math.round()
	-Math.random()


<브라우저 객체 모델 사용하기>
표준 내장 객체는 js에 내장된 객체이지만, js 언어 사양에 포함되지 않고 웹 브라우저에서 제공하는 개체가 있다. 이를 브라우저 객체 모델이라고 한다. 나중에 js로 웹 브라우저와 관련 있는 것들을 제어하려면 브라우저 객체 모델은 필수로 공부해야한다. 여기서는 활용도가 높은 객체속성과 메서드만 설명한다.

1. window 객체의 속성과 메서드
window 객체에는 웹 브라우저의 기능과 요소들을 제어할 수 있는 여러 속성과 메서드가 있다.
속성
	-innerWidth
	-innerHeight
	-outerWidth
	-outerHeight
	-screenTop/screenY
	-screenLeft/screenX
	-pageXOffset/scrollX
	-pageYOffset/scrollY
메서드
	-alert()
	-confirm()
	-prompt()
	-open()
	-close()
	-setTimeout()
	-setInterval()
	-clearInterval
	-scrollTo()
	-scrollBy()

2. window 객체의 기본 속성 사용하기
window 객체의 속성은 주로 웹 브라우저의 창과 관련 있는 속성이 많다.

3. 웹 브라우저에서 새 창 제어하기
window 객체의 open() 메서드는 웹 브라우저에서 새로운 창을 여는데 사용한다. open() 메서드는 매개변수로 창의 경로, 이름, 속성을 전달받는다.
window.open(경로, 이름, 속성);
	ex) window.open('popup.html', '팝업', 'width=200, height=100');
세번째 매개변수에 사용할 수 있는 속성 : width, height, left, top
이렇게 열린 창은 window 객체의 close() 메서드로 닫을 수 있다. close() 메서드는 보통 open()메서드로 열린 새로운 창을 닫는 용도로 사용한다.

4. 웹 브라우저의 스크롤 이동하기
window의 객체의
scrollTo() 메서드 : 웹 브라우저의 스크롤 위치를 특정 좌표로 이동하게 한다. 메서드를 여러 번 호출해도 같은 위치로 이동.
	window.scrollTo(x좌표, y좌표);
scrollBy() 메서드 : 웹 브라우저의 스크롤을 현재 위치에서 상대적인 위치로 이동하게 한다. 메서드를 여러 번 호출하면 위치 계속 이동.
	window.scrollBy(x좌표, y좌표);
단위 : px
객체 리터럴을 전달받을 수도 있다.
	ex) window.scrollTo({left:100, top:200});
위 두 메서드의 매개변수에 객체 리터럴을 전달할 때, behavior 속성을 전달할 수 있다. behavior 속성값을 smooth로 하면 웹 브라우저 스크롤이 해당 위치로 마우스 휠을 굴리듯이 부드럽게 이동한다. 단, behavior의 smooth 속성은 IE, 사파리 브라우저에서는 지원하지 않는다.
	ex) window.scrollTo({top:4000, behavior:'smooth'});


<5> 문서 객체 모델과 이벤트 다루기

HTML 문법으로 작성한 태그, 속성, 주석, 텍스트와 같은 구성 요소들은 모두 웹 브라우저에서 각각 하나의 객체로 인식. 이러한 HTML 구성 요소들을 다루는 객체를 문서 객체 모델(DOM, Document Object Model)이라고 한다.DOM은 window 객체의 document 객체를 이용해 직접 조작할 수 있다.


<문서 객체 모델>
웹 브라우저는 HTML 문서의 구성 요소를 객체로 인식한다. 웹 브라우저는 DOM을 생성할 수 있다.
DOM : 웹 브라우저에 표시되는 HTML 문서 구조를 객체화한 모델 구조. 웹 브라우저는 생성한 문서 객체 모델을 통해 HTML 문서의 구성 요소를 객체로 인식할 수 있다. js도 웹 브라우저의 문서 객체 모델을 조작해 웹 브라우저에 표시되는 HTML 문서 구조를 변경하거나 새로운 구성 요소를 추가하는 등의 작업을 할 수 있다. 단, js는 웹 브라우저에 화면이 표시된 후에 문서 객체 모델을 조작할 수 있다.

1. 문서 객체 모델이 생성되는 방식
DOM : 웹 브라우저가 HTML 문서를 해석 -> 해석한 HTML 문서 구조를 객체로 변환 -> 생성한 DOM을 웹 브라우저에 표시 -> 웹 브라우저에 표시되는 HTML 문서는 내부적으로 DOM을 해석해서 보여준다.

DOM트리 : 나무를 뒤집어 놓은 형태의 자료구조인 트리 구조를 가진다.
노드 : DOM 트리의 document 객체 하위에 HTML 태그 요소, 속성, 텍스트, 주석 등이 트리 형태로 구성되는데, 이를 노드라고 한다.
노드 TYPE : 문서 노드, 요소 노드, 속성 노드, 텍스트 노드, 주석 노드


<노드 선택하기>
js로 HTML 문서를 조작할 때 가장 먼저 할 일 : document 객체로 조작하고자 하는 DOM의 노드를 선택한다.

1. 속성으로 노드 선택하기


2. 메서드로 노드 선택하기
노트 탐색 속성으로 노드를 선택하는 방법은 DOM 트리가 복잡할수록 원하는 노드를 찾아가기 어렵다. 따라서 일반적으로 요소 노드를 바로 선택할 수 있는 메서드를 이용한다. 
	-1) get 메서드 : 속성값과 태그명 사용하기. document 객체에는 노드를 선택할 수 있는 여러 메서드가 있다.
		-getElementById(<id 속성값>) : id 속성값과 일치하는 요소 노드를 "1개만" 선택한다.
		-getElementsByClassName(<class 속성값>) : class 속성값과 일치하는 요소 노드를 모두 선택한다3.
		-getElementsByTagName(<태그명>) : 태그명과 일치하는 요소 노드를 모두 선택
	getElementById를 제외한 2개의 메서드는 HTMLCollection 객체로 여러 요소를 한꺼번에 선택하기 때문에 배열처럼 인덱스로 접근할 수 있다.
	-2) query 메서드 : CSS 선택자 사용하기
		-querySelector(<CSS 선택자>) : 매개변수로 넘어오는 CSS 선택자에 해당하는 노드를 1개만 선택
		-querySelectorAll(<CSS 선택자>) : 매개변수로 넘어오는 CSS 선택자에 해당하는 노드를 모두 선택. NodeList 객체에 담아 반환한다.

<노드 조작하기>
DOM을 선택하고 나면 선택한 노드에 여러 조작을 할 수 있다.

1. 콘텐츠 조작하기
	선택한 노드의 타입이 요소 노드라면 속성을 사용해 콘텐츠를 조작할 수 있다.
		-textContent : 요소 노드의 모든 텍스트에 접근한다.
		-innerText : 요소 노드의 텍스트 중 웹 브라우저에 표시되는 텍스트에만 접근한다.
		-innerHTML : 요소 노드의 텍스트 중 HTML 태그를 포함한 텍스트에만 접근한다.
			ex) document.getElementById("title").textContent

2. 스타일 조작하기
	선택한 노드의 타입이 요소 노드라면 style 속성으로 요소에 스타일(CSS)을 지정할 수 있다.
		-<노드>.style.<CSS 속성명> = <속성값>;

3. 클래스 속성 조작하기
	<노드>.classList.add("class 속성값"); // 추가
	<노드>.classList.remove("class 속성값"); //삭제
	<노드>.classList.toggle("class 속성값"); //추가와 삭제 반복

4. 데이터 속성 조작하기